[{"authors":[],"categories":[],"content":"Summary.\n[[动态规划]]\n动态规划的演进 Dfs -\u0026gt; 记忆化搜索 -\u0026gt; 动态规划 (倒序递推/逆序递推 -\u0026gt; 空间优化)\n[!Tip] 实现记忆化搜索，dfs 函数的参数应当尽量少，不影响边界的参数不要添加。 想要剪枝，一般多用参数\n动态规划 [[动态规划]]\n[!info] 什么是动态规划 动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题。\n动态规划的核心思想： 动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。\n示例： 下题\n// P1359 租用游艇 // https://www.luogu.com.cn/problem/P1359 #include \u0026lt;bits/stdc++.h\u0026gt; #define int long long using namespace std; const int N = 1000200; int timee[210][210]; // 直接从 i 到 j 的时间 int n; int mintime[210][210]; // 子问题分解，记录从 i 到 j 的最短时间 signed main(void) { cin \u0026gt;\u0026gt; n; for (int i=1; i\u0026lt;=n; i++) { for (int j=i+1; j\u0026lt;=n; j++) { cin \u0026gt;\u0026gt; timee[i][j]; } } // input part for (int i=1; i\u0026lt;=n; i++) { // 递推，从 1 到 i 的最短时间 -\u0026gt; 从 1 到 n 的最短时间 for (int j=i; j\u0026gt;=1; j--) { // 最后一步 if (j == i) mintime[1][i] = timee[1][i]; //！注意 else mintime[1][i] = min(mintime[1][i], timee[j][i] + mintime[1][j]); } } cout \u0026lt;\u0026lt; mintime[1][n]; return 0; } ","date":"2024年3月22日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/posts/dynamic/","series":[],"smallImg":"","tags":[],"timestamp":1711112641,"title":"Dsdfdf"},{"authors":[],"categories":[],"content":"[[搜索]]\n深度优先搜索（DFS） [[深度优先搜索]] 深度优先搜索的步骤分为 1.递归下去 2.回溯上来。 顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。\n[! EXAMPLE] 把正整数 $n$ 分解为 $3$ 个不同的正整数，如 $6=1+2+3$，排在后面的数必须大于等于前面的数，输出所有方案\n原理：\nint m, arr[103]; // 决策需要参数 n：剩下的数 i:决策层数 a:上层决策结果 void dfs(int n, int i, int a) { if (n==0) { //输出，边界条件 for (int j = 0; j \u0026lt;= i; j++) printf(\u0026#34;%d \u0026#34;, arr[j]); printf(\u0026#34;\\n\u0026#34;); } if (i\u0026lt;=m) { for (int j = a; j \u0026lt;= n; j++) { arr[i] = j; // 存下当前决策 dfs(n - j, i + 1, j); // 下一层决策 } } } 代码：Luogu P1706 全排列问题\n#include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int n; bool vis[50]; // 访问标记数组 int a[50]; // 排列数组，按顺序储存当前搜索结果 void dfs(int step) { if (step == n + 1) { // 边界 for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; a[i]; // 保留5个场宽 } cout \u0026lt;\u0026lt; endl; return; } for (int i = 1; i \u0026lt;= n; i++) { if (vis[i] == 0) { // 判断数字i是否在正在进行的全排列中 vis[i] = 1; a[step] = i; dfs(step + 1); vis[i] = 0; // 这一步不使用该数 置0后允许下一步使用 } } return; } int main() { cin \u0026gt;\u0026gt; n; dfs(1); return 0; } 关于状态回溯等 TIPS [!状态回溯]\n在进行每一层决策时，要遍历当前层所有的情况。我们通常选定当前的决策，然后根据这一层的决策进行下一层决策（也就是开启下一层 dps）。然后先清除之前的决策，再接着遍历当前层的其他\n例子 1：两种选择 -\u0026gt; 直接依次决策 kkksc03考前临时抱佛脚\nvoid dps(int i, int s_type) { if (i \u0026gt; s[s_type]) { min_sub = min ( min_sub, max(left0, right0) ); return; }\tleft0 += time0[s_type][i]; //先决策左脑 dps( i + 1, s_type); //依据当前层决策左脑的决策， 继续 dps left0 -= time0[s_type][i]; //清楚当前层决策 right0 += time0[s_type][i]; //决策右脑 dps( i + 1, s_type); right0 -= time0[s_type][i]; } 例子 2：n 种选择 -\u0026gt; 循环决策 [USACO1.5] 八皇后 Checker Challenge\nvoid queen(int i) { if (i \u0026gt;= n+1) { print(); return; } else { for (int k=1; k\u0026lt;=n; k++) // 循环 { if (b[k]==0 \u0026amp;\u0026amp; c[i+k]==0 \u0026amp;\u0026amp; d[i-k+n]==0) { a[i] = k; b[k] = 1; c[i+k] = 1; d[i-k + n] = 1; queen(i + 1); // dps b[k] = 0; // 清除 c[i+k] = 0; d[i-k + n] = 0; } } } } 例题 自然数的拆分问题\nint a[10001]={1},n; void search(int tot, int i) { if (tot == 0 \u0026amp;\u0026amp; i != 2) { //不能只输出一个数 int k; for (k=1; k\u0026lt;=i - 2; k++) { cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;\u0026#34;+\u0026#34;; } cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;endl; // i-1 return; } else { for (int j=a[i-1]; j\u0026lt;=tot; j++) //大于等于前一个数 { if (i\u0026lt;=n) // 拆分数不能比n大 { a[i] = j; search(tot - j, i + 1); // a[i] = 1; } } } } int main() { cin\u0026gt;\u0026gt;n; search(n,1); return 0; } 广度优先搜索（BFS） ","date":"2024年3月22日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2024/03/%E6%90%9C%E7%B4%A2/","series":[],"smallImg":"","tags":[],"timestamp":1711112641,"title":"搜索"},{"authors":[],"categories":[],"content":"Welcome.\n","date":"2024年3月22日","img":"/news/2024/03/welcome/feature.png","lang":"zh-hans","langName":"简体中文","largeImg":"/news/2024/03/welcome/feature_hu4b4547b9c4fda6194c6ec6c997b8c6ab_17474359_500x0_resize_box_3.png","permalink":"/news/2024/03/welcome/","series":[],"smallImg":"/news/2024/03/welcome/feature_hu4b4547b9c4fda6194c6ec6c997b8c6ab_17474359_180x0_resize_box_3.png","tags":[],"timestamp":1711104891,"title":"Welcome"},{"authors":[],"categories":[],"content":"Hi there, I\u0026rsquo;m XXX.\n","date":"2019年2月28日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":1551312000,"title":"关于我"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"联系我们"}]
