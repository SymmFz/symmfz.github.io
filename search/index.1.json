[{"authors":[],"categories":[],"content":"Summary.\ntest\nContent.\n","date":"2024年3月23日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2024/03/%E6%B5%8B%E8%AF%95/","series":[],"smallImg":"","tags":[],"timestamp":1711179367,"title":"测试"},{"authors":[],"categories":[],"content":"双指针、前缀和、差分算法.\n双指针 解释 快慢指针 左右指针 双指针是一种思想，一种技巧或一种方法，并不是什么特别具体的算法，在二分查找等算法中经常用到这个技巧。具体就是用两个变量动态存储两个或多个结点，来方便我们进行一些操作。通常用在线性的数据结构中，比如链表和数组，有时候也会用在图算法中。\n在我们遇到像数组，链表这类数据结构的算法题目的时候，应该要想得到双指针的套路来解决问题。特别是链表类的题目，经常需要用到两个或多个指针配合来记忆链表上的节点，完成某些操作。链表这种数据结构也是树形结构和图的原型，所以有时候在关于图和树形结构的算法题目中也会用到双指针。\n当你遇到此类数据结构，尝试使用双指针来解题的时候，可以从以下几个双指针类题目的套路入手进行思考\n快慢指针 类似于龟兔赛跑，两个链表上的指针从同一节点出发，其中一个指针前进速度是另一个指针的两倍。利用快慢指针可以用来解决某些算法问题，比如：\n计算链表的中点：快慢指针从头节点出发，每轮迭代中，快指针向前移动两个节点，慢指针向前移动一个节点，最终当快指针到达终点的时候，慢指针刚好在中间的节点。 判断链表是否有环：如果链表中存在环，则在链表上不断前进的指针会一直在环里绕圈子，且不能知道链表是否有环。使用快慢指针，当链表中存在环时，两个指针最终会在环中相遇。 判断链表中环的起点：当我们判断出链表中存在环，并且知道了两个指针相遇的节点，我们可以让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。 求链表中环的长度：只要相遇后一个不动，另一个前进直到相遇算一下走了多少步就好了 求链表倒数第 k 个元素：先让其中一个指针向前走 k 步，接着两个指针以同样的速度一起向前进，直到前面的指针走到尽头了，则后面的指针即为倒数第 k 个元素。（严格来说应该叫先后指针而非快慢指针） 碰撞指针 一般都是排好序的数组或链表，否则无序的话这两个指针的位置也没有什么意义。特别注意两个指针的循环条件在循环体中的变化，小心右指针跑到左指针左边去了。常用来解决的问题有:\n二分查找问题 n 数之和问题：比如两数之和问题，先对数组排序然后左右指针找到满足条件的两个数。如果是三数问题就转化为一个数和另外两个数的两数问题。以此类推。 滑动窗口法 两个指针，一前一后组成滑动窗口，并计算滑动窗口中的元素的问题。这类问题一般包括：\n字符串匹配问题 子数组问题 例题 前缀和 解释 什么是前缀和？ 一维前缀和：\n有一个一维数组 $x$ 和该数组的一维前缀和数组 $y$ ，则 $x$ 和 $y$ 满足以下关系：\n$$y_n = \\sum_{i=1}^{n} x_n$$\n二维前缀和：\n![[Clip_2024-03-16_20-10-14.png]]\n前缀和公式 一维前缀和 公式： $y_n = y_{n-1} + x_n$\n代码如下：\nfor (int i=0; i\u0026lt;n; i++) { if (i == 0) y[i] = x[i]; else y[i] = y[i-1] + x[i]; } 二维前缀和 公式：\n$$b_{x,y} = b_{x-1,y} + b_{x,y-1} - b_{x-1, y-1} + a_{x,y}$$\n代码：\nfor (int x=0; x\u0026lt;n; x++) { for (int y=0; y\u0026lt;m; y++) { if (x==0 \u0026amp;\u0026amp; y==0) b[x][y] = a[x][y]; else if (x==0) b[x][y] = b[x][y-1] + a[x][y]; else if (y==0) b[x][y] = b[x-1][y] + a[x][y]; else b[x][y] = b[x-1][y] + b[x][y-1] - b[x-1][y-1] + a[x][y]; } } [!note] 前缀和有什么用？\n前缀和是一种预处理，用于降低查询时的时间复杂度。\n举个例子：给定 n 个整数，然后进行 m 次询问，每次询问求一个区间内值的和。\n如果用暴力写法，那每次询问都需要从区间左端点循环到区间右端点求和，时间复杂度较大。\n这种时候就可以预先求出该数组的一维前缀和。\n例题 P3131 [USACO16JAN] Subsequences Summing to Sevens S\n差分 解释 差分是前缀和的逆运算。若有前缀和数组 $A_n$，差分数组 $B_n$，则有：\n$$A_i = \\sum_{i=1}^{n} B_i$$\n[!tip] 差分数组与前缀和数组的关系 差分数组与前缀和数组是一一对应的，换句话说，已知其一可确定另一数组.\n例子： 已知某前缀和数组 $A_n$ ，现需要对该前缀和数组的 $[l, r]$ 索引处的值增加 $a$ .\n解决方法：暴力复杂度 O(n) -\u0026gt; O (1)\n求解差分数组 $B_n$（差分数组 $A_i = \\sum_{i=1}^{n} B_i$ ） 增加： $B_l = B_l + a$ 消除 $r$ 后的影响：$B_{r+1} = B_{r+1} - a$ ![[Clip_2024-03-16_21-44-34.png]]\n![[Clip_2024-03-16_21-56-58.png]]\n[!NOTE] 对于二维差分？ 容易验证，二维差分数组的某一点 $(x, y)$ 所影响的范围为其右下角所有点（包括该点）\n所以，画图易知，若要使二维前缀和数组 $A_n$ $(x_1, y_1)$ 到 $(x_2, y_2)$ 之间的所有点增加 $a$. 可以使 $A_n$ 对应的二维差分数组 $S_n$ 作以下变换： $$S[x_1, y_1] += a, S[x_2 + 1, y_1] -= a, S[x_1, y_2 + 1] -= a, S[x_2 + 1, y_2 + 1] += a$$ ![[Clip_2024-03-17_11-19-39 1.png]]\n例题 一维差分 1. P 3397 地毯\n[!INFO] 题意 在 n×n 的格子上有 m 个地毯。 给出这些地毯的信息，问每个点被多少个地毯覆盖。\n此题看似为二维，其实可以用一维差分解决，见代码：\n0 0 0 0 0 0 0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 +1 0 0 0 -1 0 0 0 0 0 0 // P3397 地毯 // https://www.luogu.com.cn/problem/P3397 #include \u0026lt;bits/stdc++.h\u0026gt; #define int long long using namespace std; int n, m; int ori[1010][1010]; // 地毯数量（前缀和） int diff[1010][1010]; // 差分数组 signed main() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i=0; i\u0026lt;m; i++) { int x1, y1, x2, y2; cin \u0026gt;\u0026gt; x1 \u0026gt;\u0026gt; y1 \u0026gt;\u0026gt; x2 \u0026gt;\u0026gt; y2; for (int j=x1-1; j\u0026lt;=x2-1; j++) diff[j][y1-1] ++; for (int j=x1-1; j\u0026lt;=x2-1; j++) diff[j][y2] --; } for (int i=0; i\u0026lt;n; i++) { for (int j=0; j\u0026lt;n; j++) { if (j==0) ori[i][j] = diff[i][j]; else ori[i][j] = ori[i][j-1] + diff[i][j]; cout \u0026lt;\u0026lt; ori[i][j] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } cout \u0026lt;\u0026lt; endl; } return 0; } ","date":"2024年3月23日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2024/03/%E5%8F%8C%E6%8C%87%E9%92%88%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86%E7%AE%97%E6%B3%95/","series":[{"title":"算法笔记","url":"/series/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"smallImg":"","tags":[{"title":"双指针","url":"/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"title":"前缀和","url":"/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"title":"差分","url":"/tags/%E5%B7%AE%E5%88%86/"},{"title":"算法","url":"/tags/%E7%AE%97%E6%B3%95/"},{"title":"笔记","url":"/tags/%E7%AC%94%E8%AE%B0/"}],"timestamp":1711163400,"title":"双指针、前缀和、差分算法"},{"authors":[],"categories":[],"content":"Welcome.\n","date":"2024年3月22日","img":"/news/2024/03/welcome/feature.png","lang":"zh-hans","langName":"简体中文","largeImg":"/news/2024/03/welcome/feature_hu4b4547b9c4fda6194c6ec6c997b8c6ab_17474359_500x0_resize_box_3.png","permalink":"/news/2024/03/welcome/","series":[{"title":"News","url":"/series/news/"}],"smallImg":"/news/2024/03/welcome/feature_hu4b4547b9c4fda6194c6ec6c997b8c6ab_17474359_180x0_resize_box_3.png","tags":[],"timestamp":1711115691,"title":"Welcome"},{"authors":[],"categories":[],"content":"本文为 PyTorch 学习笔记，介绍了 PyTorch 项目的基本代码范式。\n数据的导入 数据的导入需要用到两个 PyTorch 库，分别是 torch.utils.data.Dataset 和 torch.utils.data.DataLoader\nDataset 类的使用 可以使用 Dataset 类处理自定义的数据集，示例如下：\nclass MyDataset(Dataset): def __init__(self, root_dir, label_dir): self.root_dir = root_dir self.label_dir = label_dir self.path = os.path.join(self.root_dir, self.label_dir) self.image_name = os.listdir(self.path) def __getitem__(self, idx): img_name = self.image_name[idx] img_path = os.path.join(self.path, img_name) label = self.label_dir img = Image.open(img_path) return img, label def __len__(self): return len(self.image_name) 自定义自己的数据类需要继承 PyTorch 的 Dataset 类。\n方法的重写 继承 Dataset 父类后，还需要根据数据集的具体结构和任务需求重写一些方法，其中必须重写的方法包括：__init__ 、__getitem__、__len__\n构造方法的重写 重写构造方法的目的是定义其他方法所需的属性，例如上文示例中的根路径、标签路径等等。\ngetitem 方法的重写 除了对象 self 以外，__getitem__ 方法接受一个额外的变量 idx，表示数据集中一个数据的索引。\n我们需要重写该方法，根据传入的索引返回将要输入模型的特征和标签。\nlen 方法的重写 重写该方法以定义数据集的长度，例如上文示例用图片数量定义数据集长度\n使用已有数据集 这些提供的数据集使用方式很简单，只需要按照 PyTorch 文档中的使用方法填写参数，只需一行代码即可。\n例如 CIFAR10 的使用方法如下：\ntest_set = torchvision.datasets.CIFAR10( \u0026#34;./dataset\u0026#34;, train=False, transform=torchvision.transforms.ToTensor(), download=True ) 数据的处理 处理图片 PyTorch 在 torchvision.transforms 中提供了许多处理图片的工具，例如常用的工具类 torchvision.transforms.ToTensor() 用于将 PIL 或 ndarray (使用 opencv) 格式的图片转换为 PyTorch 的 Tensor 类型，以便输入模型。\n除此之外，transform 模块还提供了常见的图片处理工具，例如图片反转、切割等等。\nDataLoader 类的使用 test_loader = DataLoader(dataset=test_set, batch_size=64, shuffle=True, num_workers=0, drop_last=False) 遍历数据集的方法：\nfor data in test_loader: imgs, targets = data 搭建模型 搭建模型有两种方式，分别是：\n从零搭建 从已有的模型搭建 从零搭建模型 首先，定义一个继承 nn.module 的模型类，然后重写方法即可，示例如下：\nclass Model(nn.Module): def __init__(self): super(Model, self).__init__() self.model = nn.Sequential( nn.Conv2d(3, 32, 5, 1, 2), nn.MaxPool2d(2), nn.LeakyReLU(), nn.Conv2d(32, 32, 5, 1, 2), nn.MaxPool2d(2), nn.LeakyReLU(), nn.Conv2d(32, 64, 5, 1, 2), nn.MaxPool2d(2), nn.LeakyReLU(), nn.Flatten(), nn.Linear(64 * 4 * 4, 256), nn.ReLU(), nn.Linear(256, 64), nn.ReLU(), nn.Linear(64, 10), ) def forward(self, x): x = self.model(x) return x 从已有的模型搭建模型 导入已有模型 获取已有的模型有两种方式，第一种方式是使用 PyTorch 提供的知名模型，例如 vgg16。\nvgg16_pt = torchvision.models.vgg16(pretrained=True) 参数 pretrained 为 True 时会下载预训练后的模型参数，反之则使用未训练的随机模型参数\n修改已有模型 有时候，下载的模型无法满足我们的任务需求，例如处理分类问题时，模型的输出层的神经元个数与我们需要区分的类别数量不同。这个时候，我们就需要修改模型。\n修改模型所用到的函数或方法主要有以下几个：\n# 1. 增加：add_module 方法，可以增加单层也可以增加 Sequential vgg16.add_module(\u0026#34;mod\u0026#34;, nn.Sequential(OrderedDict([ # 可以不给每层取名 (\u0026#34;linear\u0026#34;, nn.Linear(1000, 256)), (\u0026#34;relu\u0026#34;, nn.ReLU()), (\u0026#34;softmax\u0026#34;, nn.Softmax(10)) ]))) vgg16.add_module(nn.Linear(64, 10)) # 2. 修改：直接使用 [idx] 和 `.` print(vgg16) # 先print查看模型结构 vgg16.classifier[6] = nn.Linear(64, 10) vgg16.classifier[6] = nn.Sequential( nn.Linear(64, 10), nn.Linear(10, 5) ) # 3. 删除：使用 del 即可 del vgg16.classifier 训练模型 下面提供一个训练示例：\n# * 3. Create the model object and Setting hyperparameters # create model object model = Model() if torch.cuda.is_available(): model = model.cuda() # define the loss function loss_fn = nn.CrossEntropyLoss() if torch.cuda.is_available(): loss_fn = loss_fn.cuda() # define the optimizer learning_rate = 0.01 optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) # optimizer = torch.optim.Adam(model.parameters()) # Setting total_train_step = 0 total_test_step = 0 epoch = 30 # set tensorboard writer = SummaryWriter(\u0026#34;./logs_model\u0026#34;) # * 4. Training the model for i in range(epoch): print(f\u0026#34;------ Epoch {i} begin. ------\u0026#34;) start_time = time.time() # train model.train() # for some certain layer(such as dropout), See PyTorch.org. for data in train_dataloader: imgs, targets = data # move to gpu if torch.cuda.is_available(): imgs, targets = imgs.cuda(), targets.cuda() output = model(imgs) loss = loss_fn(output, targets) # optimize optimizer.zero_grad() loss.backward() optimizer.step() total_train_step = total_train_step + 1 if total_train_step % 100 == 0: print(f\u0026#34;Train step: {total_train_step} / Loss: {loss}\u0026#34;) end_time = time.time() print(f\u0026#34;tic {end_time-start_time}\u0026#34;) writer.add_scalar(\u0026#34;train_loss(step)\u0026#34;, loss, total_train_step) # test model.eval() # for some certain layer total_test_loss = 0 total_accuracy = 0 with torch.no_grad(): for data in test_dataloader: imgs, targets = data # move to gpu if torch.cuda.is_available(): imgs, targets = imgs.cuda(), targets.cuda() output = model(imgs) # compute accuracy accuracy = (output.argmax(1) == targets).sum() total_accuracy += accuracy loss = loss_fn(output, targets) total_test_loss += loss # Show and log test info print(ColorText.info(f\u0026#34;\\nTotal loss in test set: {total_test_loss}\u0026#34;)) print( ColorText.info(f\u0026#34;Total accuracy in test set: {total_accuracy / test_set_size}\u0026#34;) ) writer.add_scalar(\u0026#34;test_loss(epoch)\u0026#34;, total_test_loss, total_test_step) writer.add_scalar( \u0026#34;test_accuracy(epoch)\u0026#34;, total_accuracy / test_set_size, total_test_step ) total_test_step += 1 # Save Model torch.save(model, f\u0026#34;model_{i}.pt\u0026#34;) print(ColorText.info(f\u0026#34;..::Model {i} Saved..\u0026#34;)) writer.close() 附录 Tensorboard 的使用 示例：\n首先在脚本内记录数据到指定路径\nfrom torch.urils.tensorboard import SummaryWriter # writer 对象 writer = SummaryWriter(\u0026#34;./logs\u0026#34;) # log_dir # 记录数据 writer.add_scalar(\u0026#34;loss curve\u0026#34;, y_value, x_value) # writer.close() 然后，命令行用 Tensorboard 打开日志路径\ntensorboard --log_dir ./logs ","date":"2024年3月22日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2024/03/pytorch/","series":[],"smallImg":"","tags":[{"title":"深度学习","url":"/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"title":"PyTorch","url":"/tags/pytorch/"}],"timestamp":1711112701,"title":"PyTorch"},{"authors":[],"categories":[],"content":"W.I.P 动态规划学习笔记.\n动态规划的演进 Dfs -\u0026gt; 记忆化搜索 -\u0026gt; 动态规划 (倒序递推/逆序递推 -\u0026gt; 空间优化)\n实现记忆化搜索，dfs 函数的参数应当尽量少，不影响边界的参数不要添加。 想要剪枝，一般多用参数\n动态规划 什么是动态规划 动态规划（英语：Dynamic programming，简称 DP），是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 动态规划常常适用于有重叠子问题和最优子结构性质的问题。\n动态规划的核心思想： 动态规划最核心的思想，就在于拆分子问题，记住过往，减少重复计算。\n示例： 下题\n// P1359 租用游艇 // https://www.luogu.com.cn/problem/P1359 #include \u0026lt;bits/stdc++.h\u0026gt; #define int long long using namespace std; const int N = 1000200; int timee[210][210]; // 直接从 i 到 j 的时间 int n; int mintime[210][210]; // 子问题分解，记录从 i 到 j 的最短时间 signed main(void) { cin \u0026gt;\u0026gt; n; for (int i=1; i\u0026lt;=n; i++) { for (int j=i+1; j\u0026lt;=n; j++) { cin \u0026gt;\u0026gt; timee[i][j]; } } // input part for (int i=1; i\u0026lt;=n; i++) { // 递推，从 1 到 i 的最短时间 -\u0026gt; 从 1 到 n 的最短时间 for (int j=i; j\u0026gt;=1; j--) { // 最后一步 if (j == i) mintime[1][i] = timee[1][i]; //！注意 else mintime[1][i] = min(mintime[1][i], timee[j][i] + mintime[1][j]); } } cout \u0026lt;\u0026lt; mintime[1][n]; return 0; } ","date":"2024年3月22日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2024/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","series":[],"smallImg":"","tags":[{"title":"算法，动态规划","url":"/tags/%E7%AE%97%E6%B3%95%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}],"timestamp":1711112641,"title":"动态规划"},{"authors":[],"categories":[],"content":"本文为搜索算法学习笔记。\n深度优先搜索（DFS） 深度优先搜索的步骤分为 1.递归下去 2.回溯上来。 顾名思义，深度优先，则是以深度为准则，先一条路走到底，直到达到目标。这里称之为递归下去。否则既没有达到目标又无路可走了，那么则退回到上一步的状态，走其他路。这便是回溯上来。\n把正整数 $n$ 分解为 $3$ 个不同的正整数，如 $6=1+2+3$，排在后面的数必须大于等于前面的数，输出所有方案\n原理：\nint m, arr[103]; // 决策需要参数 n：剩下的数 i:决策层数 a:上层决策结果 void dfs(int n, int i, int a) { if (n==0) { //输出，边界条件 for (int j = 0; j \u0026lt;= i; j++) printf(\u0026#34;%d \u0026#34;, arr[j]); printf(\u0026#34;\\n\u0026#34;); } if (i\u0026lt;=m) { for (int j = a; j \u0026lt;= n; j++) { arr[i] = j; // 存下当前决策 dfs(n - j, i + 1, j); // 下一层决策 } } } 代码：Luogu P1706 全排列问题\n#include \u0026lt;iomanip\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int n; bool vis[50]; // 访问标记数组 int a[50]; // 排列数组，按顺序储存当前搜索结果 void dfs(int step) { if (step == n + 1) { // 边界 for (int i = 1; i \u0026lt;= n; i++) { cout \u0026lt;\u0026lt; setw(5) \u0026lt;\u0026lt; a[i]; // 保留5个场宽 } cout \u0026lt;\u0026lt; endl; return; } for (int i = 1; i \u0026lt;= n; i++) { if (vis[i] == 0) { // 判断数字i是否在正在进行的全排列中 vis[i] = 1; a[step] = i; dfs(step + 1); vis[i] = 0; // 这一步不使用该数 置0后允许下一步使用 } } return; } int main() { cin \u0026gt;\u0026gt; n; dfs(1); return 0; } 关于状态回溯等 TIPS [!状态回溯]\n在进行每一层决策时，要遍历当前层所有的情况。我们通常选定当前的决策，然后根据这一层的决策进行下一层决策（也就是开启下一层 dps）。然后先清除之前的决策，再接着遍历当前层的其他\n例子 1：两种选择 -\u0026gt; 直接依次决策 kkksc03考前临时抱佛脚\nvoid dps(int i, int s_type) { if (i \u0026gt; s[s_type]) { min_sub = min ( min_sub, max(left0, right0) ); return; }\tleft0 += time0[s_type][i]; //先决策左脑 dps( i + 1, s_type); //依据当前层决策左脑的决策， 继续 dps left0 -= time0[s_type][i]; //清楚当前层决策 right0 += time0[s_type][i]; //决策右脑 dps( i + 1, s_type); right0 -= time0[s_type][i]; } 例子 2：n 种选择 -\u0026gt; 循环决策 [USACO1.5] 八皇后 Checker Challenge\nvoid queen(int i) { if (i \u0026gt;= n+1) { print(); return; } else { for (int k=1; k\u0026lt;=n; k++) // 循环 { if (b[k]==0 \u0026amp;\u0026amp; c[i+k]==0 \u0026amp;\u0026amp; d[i-k+n]==0) { a[i] = k; b[k] = 1; c[i+k] = 1; d[i-k + n] = 1; queen(i + 1); // dps b[k] = 0; // 清除 c[i+k] = 0; d[i-k + n] = 0; } } } } 例题 自然数的拆分问题\nint a[10001]={1},n; void search(int tot, int i) { if (tot == 0 \u0026amp;\u0026amp; i != 2) { //不能只输出一个数 int k; for (k=1; k\u0026lt;=i - 2; k++) { cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;\u0026#34;+\u0026#34;; } cout\u0026lt;\u0026lt;a[k]\u0026lt;\u0026lt;endl; // i-1 return; } else { for (int j=a[i-1]; j\u0026lt;=tot; j++) //大于等于前一个数 { if (i\u0026lt;=n) // 拆分数不能比n大 { a[i] = j; search(tot - j, i + 1); // a[i] = 1; } } } } int main() { cin\u0026gt;\u0026gt;n; search(n,1); return 0; } 广度优先搜索（BFS） W.I.P\n","date":"2024年3月22日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/2024/03/%E6%90%9C%E7%B4%A2/","series":[],"smallImg":"","tags":[],"timestamp":1711112641,"title":"搜索"},{"authors":[],"categories":[],"content":"Hi there, I\u0026rsquo;m SymmFz.\nWelcome to my blog.\n","date":"2024年3月22日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/about/","series":[],"smallImg":"","tags":[],"timestamp":1711065600,"title":"关于我"},{"authors":[],"categories":[],"content":" 9.1 创建和使用类 这个类让 Python 知道如何创建表示小狗的对象。编写这个类后，我们将使用它来创建表示特定小狗的实例。\n根据约定，在 Python 中，首字母大写的名称指的是类\n9.1.1 创建 Dog 类 class Dog(): \u0026#34;\u0026#34;\u0026#34;一次模拟小狗的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, name, age): \u0026#34;\u0026#34;\u0026#34;初始化属性 name 和 age\u0026#34;\u0026#34;\u0026#34; self.name = name self.age = age def sit(self): \u0026#34;\u0026#34;\u0026#34;模拟小狗被命令时蹲下\u0026#34;\u0026#34;\u0026#34; print(self.name.title() + \u0026#34; is now sitting.\u0026#34;) def roll_over(self): \u0026#34;\u0026#34;\u0026#34;模拟小狗被命令时打滚\u0026#34;\u0026#34;\u0026#34; print(self.name.title() + \u0026#34; rolled over!\u0026#34;) 这个类定义中的括号是空的，因为我们要从空白创建这个类 (子类则括号内有内容)。\n1. 方法 __init__() 类中的函数称为方法；你前面学到的有关函数的一切都适用于方法，就目前而言，唯一重要的差别是调用方法的方式\n方法 __init__() 是一个特殊的方法，每当你根据 Dog 类创建新实例时，Python 都会自动运行它。\n开头和末尾各有两个下划线，旨在避免 Python 默认方法与普通方法发生名称冲突\n我们将方法 __init__() 定义成了包含三个形参：self、name 和 age 。在这个方法的定义中，形参 self 必不可少，还必须位于其他形参的前面。\n[!info] 为何必须在方法定义中包含形参 self 呢？ 因为 Python 调用这个 init() 方法来创建 Dog 实例时，将自动传入实参 self。每个与类相关联的方法调用都自动传递实参 self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。\n我们创建 Dog 实例时，Python 将调用 Dog 类的方法 __init__()。我们将通过实参向 Dog() 传递名字和年龄；self 会自动传递，因此我们不需要传递它。每当我们根据 Dog 类创建实例时，都只需给最后两个形参（name 和 age）提供值。\n定义的两个变量都有前缀 self。以 self 为前缀的变量都可供类中的所有方法使用，我们还可以通过类的任何实例来访问这些变量。\nself.name = name 获取存储在形参 name 中的值，并将其存储到变量 name 中，然后该变量被关联到当前创建的实例。self.age = age 的作用与此类似。像这样可通过实例访问的变量称为属性。\n9.1.2 根据类创建实例 可将类视为有关如何创建实例的说明\nmy_dog = Dog(\u0026#39;willie\u0026#39;, 6) print(\u0026#34;My dog\u0026#39;s name is \u0026#34; + my_dog.name.title() + \u0026#34;.\u0026#34;) print(\u0026#34;My dog is \u0026#34; + str(my_dog.age) + \u0026#34; years old.\u0026#34;) 我们让 Python 创建一条名字为 'willie'、年龄为 6 的小狗。遇到这行代码时，Python 使用实参 'willie' 和 6 调用 Dog 类中的方法 __init__()。方法 __init__() 创建一个表示特定小狗的示例，并使用我们提供的值来设置属性 name 和 age。方法 __init__() 并未显式地包含 return 语句，但 Python 自动返回一个表示这条小狗的实例。我们将这个实例存储在变量 my_dog 中。在这里，命名约定很有用：我们通常可以认为首字母大写的名称（如 Dog）指的是类，而小写的名称（如 my_dog）指的是根据类创建的实例\n1. 访问属性 my_dog.name\n要访问实例的属性，可使用句点表示法。在这里，Python 先找到实例 my_dog，再查找与这个实例相关联的属性 name。\n在 Dog 类中引用这个属性时，使用的是 self.name\n2. 调用方法 根据 Dog 类创建实例后，就可以使用句点表示法来调用 Dog 类中定义的任何方法\nmy_dog.sit() my_dog.roll_over()\n3. 创建多个实例 9.2 使用类和实例 9.2.1Car 类 class Car(): \u0026#34;\u0026#34;\u0026#34;一次模拟汽车的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34;初始化描述汽车的属性\u0026#34;\u0026#34;\u0026#34; self.make = make self.model = model self.year = year def get_descriptive_name(self): \u0026#34;\u0026#34;\u0026#34;返回整洁的描述性信息\u0026#34;\u0026#34;\u0026#34; long_name = str(self.year) + \u0026#39; \u0026#39; + self.make + \u0026#39; \u0026#39; + self.model return long_name.title() my_new_car = Car(\u0026#39;audi\u0026#39;, \u0026#39;a4\u0026#39;, 2016) print(my_new_car.get_descriptive_name()) 9.2.2 给属性指定默认值 类中的每个属性都必须有初始值，哪怕这个值是 0 或空字符串。在有些情况下，如设置默认值时，在方法 __init__() 内指定这种初始值是可行的；如果你对某个属性这样做了，就无需包含为它提供初始值的形参\nself.odometer_reading = 0\nclass Car(): def __init__(self, make, model, year): self.make = make self.model = model self.year = year self.odometer_reading = 0 def get_descriptive_name(self): pass def read_odometer(self): \u0026#34;\u0026#34;\u0026#34;打印一条指出汽车里程的消息\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;This car has \u0026#34; + str(self.odometer_reading) + \u0026#34; miles on it.\u0026#34;) my_new_car = Car(\u0026#39;audi\u0026#39;, \u0026#39;a4\u0026#39;, 2016) print(my_new_car.get_descriptive_name()) my_new_car.read_odometer() 9.2.3 修改属性的值 直接通过实例进行修改 通过方法进行设置 通过方法进行递增（增加特定的值） 1. 直接修改属性的值 最简单的方式是通过实例直接访问它\nmy_new_car.odometer_reading = 23\n2. 通过方法修改属性的值 这样，你就无需直接访问属性，而可将值传递给一个方法，由它在内部进行更新\nclass Car(): --snip-- def update_odometer(self, mileage): \u0026#34;\u0026#34;\u0026#34;将里程表读数设置为指定的值\u0026#34;\u0026#34;\u0026#34; self.odometer_reading = mileage my_new_car.update_odometer(23) 可对方法 update_odometer() 进行扩展，使其在修改里程表读数时做些额外的工作。下面来添加一些逻辑，禁止任何人将里程表读数往回调\ndef update_odometer(self, mileage): \u0026#34;\u0026#34;\u0026#34; 将里程表读数设置为指定的值禁止将里程表读数往回调 \u0026#34;\u0026#34;\u0026#34; if mileage \u0026gt;= self.odometer_reading: self.odometer_reading = mileage else: print(\u0026#34;You can\u0026#39;t roll back an odometer!\u0026#34;) 3. 通过方法对属性的值进行递增 下面的方法让我们能够传递这个增量，并相应地增加里程表读数：\ndef increment_odometer(self, miles): \u0026#34;\u0026#34;\u0026#34;将里程表读数增加指定的量\u0026#34;\u0026#34;\u0026#34; self.odometer_reading += miles my_used_car.increment_odometer(100) 注意你可以使用类似于上面的方法来控制用户修改属性值（如里程表读数）的方式，但能够访问程序的人都可以通过直接访问属性来将里程表修改为任何值。要确保安全，除了进行类似于前面的基本检查外，还需特别注意细节\n9.3 继承 编写类时，并非总是要从空白开始。如果你要编写的类是另一个现成类的特殊版本，可使用继承。\n一个类继承另一个类时，它将自动获得另一个类的所有属性和方法；原有的类称为父类，而新类称为子类。子类继承了其父类的所有属性和方法，同时还可以定义自己的属性和方法。\n9.3.1 子类的方法 init() super().__init__(make, model, year)\n创建子类的实例时，Python 首先需要完成的任务是给父类的所有属性赋值。为此，子类的方法 __init__() 需要父类施以援手\n创建子类时，父类必须包含在当前文件中，且位于子类前面。定义子类时，必须在括号内指定父类的名称。方法 init() 接受创建 Car 实例所需的信息\n父类也称为超类（superclass），名称 super 因此而得名。\ndef __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34; 电动汽车的独特之处初始化父类的属性，再初始化电动汽车特有的属性 \u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) self.battery_size = 70 9.3.4 重写父类的方法 子类的同名方法覆盖父类的同名方法\ndef ElectricCar(Car): --snip-- def fill_gas_tank(): \u0026#34;\u0026#34;\u0026#34;电动汽车没有油箱\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;This car doesn\u0026#39;t need a gas tank!\u0026#34;) 对于父类的方法，只要它不符合子类模拟的实物的行为，都可对其进行重写。为此，可在子类中定义一个这样的方法，即它与要重写的父类方法同名。这样，Python 将不会考虑这个父类方法，而只关注你在子类中定义的相应方法。\n9.3.5 将实例用作属性 self.battery = Battery()\nclass Battery(): \u0026#34;\u0026#34;\u0026#34;一次模拟电动汽车电瓶的简单尝试\u0026#34;\u0026#34;\u0026#34; def __init__(self, battery_size=70): \u0026#34;\u0026#34;\u0026#34;初始化电瓶的属性\u0026#34;\u0026#34;\u0026#34; self.battery_size = battery_size def describe_battery(self): \u0026#34;\u0026#34;\u0026#34;打印一条描述电瓶容量的消息\u0026#34;\u0026#34;\u0026#34; print(\u0026#34;This car has a \u0026#34; + str(self.battery_size) + \u0026#34;-kWh battery.\u0026#34;) class ElectricCar(Car): \u0026#34;\u0026#34;\u0026#34;电动汽车的独特之处\u0026#34;\u0026#34;\u0026#34; def __init__(self, make, model, year): \u0026#34;\u0026#34;\u0026#34; 初始化父类的属性，再初始化电动汽车特有的属性 \u0026#34;\u0026#34;\u0026#34; super().__init__(make, model, year) self.battery = Battery() # heeeeeerrrrr 将实例用作属性 def get_range(self): \u0026#34;\u0026#34;\u0026#34;打印一条消息，指出电瓶的续航里程\u0026#34;\u0026#34;\u0026#34; if self.battery_size == 70: range = 240 elif self.battery_size == 85: range = 270 message = \u0026#34;This car can go approximately \u0026#34; + str(range) message += \u0026#34; miles on a full charge.\u0026#34; print(message) my_tesla = ElectricCar(\u0026#39;tesla\u0026#39;, \u0026#39;model s\u0026#39;, 2016) print(my_tesla.get_descriptive_name()) my_tesla.battery.describe_battery() [!tip] 将类的一部分作为一个独立的类提取出来。你可以将大型类拆分成多个协同工作的小类。这看似做了很多额外的工作，但现在我们想多详细地描述电瓶都可以，且不会导致 ElectricCar 类混乱不堪。\n9.4 导入类 from car import Car\n9.4.2 在一个模块中存储多个类 9.4.3 从一个模块中导入多个类 from car import Car, ElectricCar\n9.4.4 导入整个模块 导入整个模块，再使用句点表示法访问需要的类。\nimport car\ncar.Car('volkswagen', 'beetle', 2016)\n9.4.5 导入模块中的所有类 from module_name import *\n9.4.6 TIPS 需要从一个模块中导入很多类时，最好导入整个模块，并使用 module_name.class_name 语法来访问类。这样做时，虽然文件开头并没有列出用到的所有类，但你清楚地知道在程序的哪些地方使用了导入的模块；你还避免了导入模块中的每个类可能引发的名称冲突。\n冒泡排序 // 假设数组的大小是 n + 1，冒泡排序从数组下标 1 开始 void bubble_sort(int *a, int n) { bool flag = true; while (flag) { flag = false; for (int i = 1; i \u0026lt; n; ++i) { if (a[i] \u0026gt; a[i + 1]) { flag = true; int t = a[i]; a[i] = a[i + 1]; a[i + 1] = t; } } } } 插入排序 定义 插入排序（英语：Insertion sort）是一种简单直观的排序算法。它的工作原理为将待排列元素划分为「已排序」和「未排序」两部分，每次从「未排序的」元素中选择一个插入到「已排序的」元素中的正确位置。 一个与插入排序相同的操作是打扑克牌时，从牌桌上抓一张牌，按牌面大小插到手牌后，再抓下一张牌。\nvoid insertion_sort(int arr[], int len) { for (int i = 1; i \u0026lt; len; ++i) { int key = arr[i]; int j = i - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; arr[j] \u0026gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } } 排序相关 STL 本页面将简要介绍 C 和 C++ 标准库中实现的排序算法。 除已说明的函数外，本页所列函数默认定义于头文件 \u0026lt;algorithm\u0026gt; 中。\nqsort 参见：qsort，std::qsort 该函数为 C 标准库实现的 快速排序，定义在 \u0026lt;stdlib.h\u0026gt; 中。在 C++ 标准库里，该函数定义在 \u0026lt;cstdlib\u0026gt; 中。\nqsort 与 bsearch 的比较函数 qsort 函数有四个参数：数组名、元素个数、元素大小、比较规则。其中，比较规则通过指定比较函数来实现，指定不同的比较函数可以实现不同的排序规则。 比较函数的参数限定为两个 const void 类型的指针。返回值规定为正数、负数和 0。 比较函数的一种示例写法为：\nint compare(const void *p1, const void *p2) // int 类型数组的比较函数 { int *a = (int *)p1; int *b = (int *)p2; if (*a \u0026gt; *b) return 1; // 返回正数表示 a 大于 b else if (*a \u0026lt; *b) return -1; // 返回负数表示 a 小于 b else return 0; // 返回 0 表示 a 与 b 等价 } 注意：返回值用两个元素相减代替正负数是一种典型的错误写法，因为这样可能会导致溢出错误。 以下是排序结构体的一个示例：\nstruct eg // 示例结构体 { int e; int g; }; int compare(const void *p1, const void *p2) // struct eg 类型数组的比较函数：按成员 e 排序 { struct eg *a = (struct eg *)p1; struct eg *b = (struct eg *)p2; if (a-\u0026gt;e \u0026gt; b-\u0026gt;e) return 1; // 返回正数表示 a 大于 b else if (a-\u0026gt;e \u0026lt; b-\u0026gt;e) return -1; // 返回负数表示 a 小于 b else return 0; // 返回 0 表示 a 与 b 等价 }``` 这里也可以看出，等价不代表相等，只代表在此比较规则下两元素等价。 ## std::sort[](https://oi-wiki.org/basic/stl-sort/#stdsort \u0026#34;Permanent link\u0026#34;) 参见：[`std::sort`](https://zh.cppreference.com/w/cpp/algorithm/sort) 用法： ```c // a[0] .. a[n - 1] 为需要排序的数列 // 对 a 原地排序，将其按从小到大的顺序排列 std::sort(a, a + n); // cmp 为自定义的比较函数 std::sort(a, a + n, cmp); 注意：sort 的比较函数的返回值是 true 和 false，用 true 和 false 表示两个元素的大小（先后）关系，这与 qsort 的三值比较函数的语义完全不同。具体内容详见上方给出的 sort 的文档。 如果要将 sort 简单改写为 qsort，维持排序顺序整体上不变（不考虑等价的元素），需要将返回 true 改为 - 1，返回 false 改为 1。 std::sort 函数是更常用的 C++ 库比较函数。该函数的最后一个参数为二元比较函数，未指定 cmp 函数时，默认按从小到大的顺序排序。 旧版 C++ 标准中仅要求它的 平均 时间复杂度达到 。C++11 标准以及后续标准要求它的 最坏 时间复杂度达到 。 C++ 标准并未严格要求此函数的实现算法，具体实现取决于编译器。libstdc++ 和 libc++ 中的实现都使用了 内省排序。\nstd::nth_element 参见：std::nth_element 用法\nstd::nth_element(first, nth, last); std::nth_element(first, nth, last, cmp); 它重排 [first, last) 中的元素，使得 nth 所指向的元素被更改为 [first, last) 排好序后该位置会出现的元素。这个新的 nth 元素前的所有元素小于或等于新的 nth 元素后的所有元素。 实现算法是未完成的内省排序。 对于以上两种用法，C++ 标准要求它的平均时间复杂度为 ，其中 n 为 std::distance(first, last)。 它常用于构建 K-D Tree。\nstd::stable_sort 参见：std::stable_sort 用法：\nstd::stable_sort(first, last); std::stable_sort(first, last, cmp); 稳定排序，保证相等元素排序后的相对位置与原序列相同。 时间复杂度为 ，当额外内存可用时，复杂度为 。\nstd::partial_sort 参见：std::partial_sort 用法：\n// mid = first + k std::partial_sort(first, mid, last); std::partial_sort(first, mid, last, cmp); 将序列中前 k 元素按 cmp 给定的顺序进行原地排序，后面的元素不保证顺序。未指定 cmp 函数时，默认按从小到大的顺序排序。 复杂度：约 次应用 cmp。 原理： std::partial_sort 的思想是：对原始容器内区间为 [first, mid) 的元素执行 make_heap() 操作，构造一个大根堆，然后将 [mid, last) 中的每个元素和 first 进行比较，保证 first 内的元素为堆内的最大值。如果小于该最大值，则互换元素位置，并对 [first, mid) 内的元素进行调整，使其保持最大堆序。比较完之后，再对 [first, mid) 内的元素做一次堆排序 sort_heap() 操作，使其按增序排列。注意，堆序和增序是不同的。\n自定义比较 参见：运算符重载\n内置类型（如 int）和用户定义的结构体允许定制调用 STL 排序函数时使用的比较函数。可以在调用该函数时，在最后一个参数中传入一个实现二元比较的函数。 对于用户定义的结构体，对其使用 STL 排序函数前必须定义至少一种关系运算符，或是在使用函数时提供二元比较函数。通常推荐定义 operator\u0026lt;。1\n示例：\nint a[1009], n = 10; // ... std::sort(a + 1, a + 1 + n); // 从小到大排序 std::sort(a + 1, a + 1 + n, greater\u0026lt;int\u0026gt;()); // 从大到小排序 struct data { int a, b; bool operator\u0026lt;(const data rhs) const { return (a == rhs.a) ? (b \u0026lt; rhs.b) : (a \u0026lt; rhs.a); } } da[1009]; bool cmp(const data u1, const data u2) { return (u1.a == u2.a) ? (u1.b \u0026gt; u2.b) : (u1.a \u0026gt; u2.a); } // ... std::sort(da + 1, da + 1 + 10); // 使用结构体中定义的 \u0026lt; 运算符，从小到大排序 std::sort(da + 1, da + 1 + 10, cmp); // 使用 cmp 函数进行比较，从大到小排序 ","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/blog/1/01/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":""},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/offline/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"Offline"},{"authors":[],"categories":[],"content":"","date":"1年1月1日","img":"","lang":"zh-hans","langName":"简体中文","largeImg":"","permalink":"/contact/","series":[],"smallImg":"","tags":[],"timestamp":-62135596800,"title":"联系我们"}]
